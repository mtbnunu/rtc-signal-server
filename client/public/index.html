<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Host and Joiner</title>
</head>

<body>
  <h1>WebRTC Signaling Example</h1>
  <button id="hostBtn">Create Room (Host)</button>
  <button id="joinBtn">Join Room</button>
  <input type="text" id="roomIdInput" placeholder="Enter Room ID">
  <pre id="output"></pre>

  <script>
    const signalingServerUrl = 'wss://urmdrodnf9.execute-api.us-east-1.amazonaws.com/dev/'; // Replace with your WebSocket API endpoint

    const output = document.getElementById('output');
    const hostBtn = document.getElementById('hostBtn');
    const joinBtn = document.getElementById('joinBtn');
    const roomIdInput = document.getElementById('roomIdInput');

    let socket;
    let peerConnections = {};
    let iceCandidateQueues = {};

    // Function to start WebRTC and handle ICE candidates
    async function startWebRTC(peerConnection, remoteConnectionId, isHost) {
      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          console.log('sending websocket', {
            action: 'candidate',
            roomId: socket.connectionId,
            targetId: remoteConnectionId,
            candidate: event.candidate
          })
          socket.send(JSON.stringify({
            action: 'candidate',
            roomId: socket.connectionId,
            targetId: remoteConnectionId,
            candidate: event.candidate
          }));
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log('ICE connection state change:', peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'connected' && peerConnection.connectionState === 'connected') {
          console.log('ICE connection state is connected, closing WebSocket connection');
          socket.close();
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Peer connection state change:', peerConnection.connectionState);
        if (peerConnection.connectionState === 'connected') {
          console.log('Peer connection state is connected, closing WebSocket connection');
          socket.close();
        }
      };

      if (isHost) {
        const dataChannel = peerConnection.createDataChannel("dataChannel");
        dataChannel.onopen = () => {
          console.log("Data channel is open");
          peerConnections[remoteConnectionId].dataChannel = dataChannel;
        };
        dataChannel.onclose = () => {
          console.log("Data channel is closed");
        };
        dataChannel.onmessage = event => onWebRTCReceived(JSON.parse(event.data));
      } else {
        peerConnection.ondatachannel = event => {
          const dataChannel = event.channel;
          dataChannel.onopen = () => {
            console.log("Data channel is open");
            peerConnections[remoteConnectionId].dataChannel = dataChannel;
          };
          dataChannel.onclose = () => {
            console.log("Data channel is closed");
          };
          dataChannel.onmessage = event => onWebRTCReceived(JSON.parse(event.data));
        };
      }

      // Process any queued ICE candidates
      if (iceCandidateQueues[remoteConnectionId]) {
        while (iceCandidateQueues[remoteConnectionId].length > 0) {
          const candidate = iceCandidateQueues[remoteConnectionId].shift();
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        }
      }
    }

    function createRoom() {
      socket = new WebSocket(signalingServerUrl);

      socket.onopen = () => {
        console.log('WebSocket connection opened for host');
        socket.send(JSON.stringify({ action: 'createRoom' }));
      };

      socket.onmessage = async event => {
        const message = JSON.parse(event.data);
        console.log('Received WebSocket message:', message);
        switch (message.action) {
          case 'roomCreated':
            output.textContent = `Room created with ID: ${message.roomId}`;
            socket.connectionId = message.roomId;
            break;
          case 'newJoiner':
            const peerConnection = new RTCPeerConnection();
            peerConnections[message.sourceId] = peerConnection;
            await startWebRTC(peerConnection, message.sourceId, true);

            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            socket.send(JSON.stringify({
              action: 'offer',
              roomId: socket.connectionId,
              targetId: message.sourceId,
              sdp: offer
            }));
            break;
          case 'answer':
            await peerConnections[message.sourceId].setRemoteDescription(new RTCSessionDescription(message.sdp));
            break;
          case 'candidate':
            if (peerConnections[message.sourceId]) {
              await peerConnections[message.sourceId].addIceCandidate(new RTCIceCandidate(message.candidate));
            } else {
              if (!iceCandidateQueues[message.sourceId]) {
                iceCandidateQueues[message.sourceId] = [];
              }
              iceCandidateQueues[message.sourceId].push(message.candidate);
            }
            break;
          case 'roomClosed':
            output.textContent = `Room closed by host`;
            socket.close();
            break;
          default:
            console.log(`Unknown message action: ${message.action}`);
        }
      };

      socket.onclose = () => {
        console.log('WebSocket connection closed');
      };

      socket.onerror = error => {
        console.error('WebSocket error:', error);
      };
    }

    function joinRoom() {
      const roomId = roomIdInput.value;
      if (!roomId) {
        alert('Please enter a room ID');
        return;
      }

      socket = new WebSocket(signalingServerUrl);

      socket.onopen = () => {
        console.log('WebSocket connection opened for joiner');
        socket.send(JSON.stringify({ action: 'joinRoom', roomId: roomId }));
      };

      socket.onmessage = async event => {
        const message = JSON.parse(event.data);
        console.log('Received WebSocket message:', message);
        switch (message.action) {
          case 'offer':
            const peerConnection = new RTCPeerConnection();
            peerConnections[message.roomId] = peerConnection;
            await startWebRTC(peerConnection, message.roomId, false);

            await peerConnection.setRemoteDescription(new RTCSessionDescription(message.sdp));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            socket.send(JSON.stringify({
              action: 'answer',
              targetId: message.roomId,
              sdp: answer
            }));

            // Keep the WebSocket connection open until all signaling is complete
            break;
          case 'candidate':
            if (peerConnections[message.roomId]) {
              await peerConnections[message.roomId].addIceCandidate(new RTCIceCandidate(message.candidate));
            } else {
              if (!iceCandidateQueues[message.roomId]) {
                iceCandidateQueues[message.roomId] = [];
              }
              iceCandidateQueues[message.roomId].push(message.candidate);
            }
            break;
          case 'roomNotFound':
            output.textContent = `Room not found`;
            socket.close();
            break;
          default:
            console.log(`Unknown message action: ${message.action}`);
        }
      };

      socket.onclose = () => {
        console.log('WebSocket connection closed');
      };

      socket.onerror = error => {
        console.error('WebSocket error:', error);
      };
    }

    // Function to handle received WebRTC data
    function onWebRTCReceived(data) {
      console.log('Received data:', data);
      // Handle received data
      output.textContent += `\nReceived: ${JSON.stringify(data)}`;
    }

    // Function to send WebRTC data
    function sendWebRTC(remoteConnectionId, data) {
      const dataChannel = peerConnections[remoteConnectionId]?.dataChannel;
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify(data));
        console.log('Sent data:', data);
        output.textContent += `\nSent: ${JSON.stringify(data)}`;
      } else {
        console.log('Data channel is not open');
      }
    }

    hostBtn.addEventListener('click', createRoom);
    joinBtn.addEventListener('click', joinRoom);
  </script>
</body>

</html>
